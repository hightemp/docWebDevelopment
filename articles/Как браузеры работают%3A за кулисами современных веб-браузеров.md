# Как браузеры работают: за кулисами современных веб-браузеров

## Предисловие

Этот всеобъемлющий учебник по внутренним операциям WebKit и Gecko является результатом большого исследования, проведенного израильским разработчиком Тали Гарсиэль. За несколько лет она проверила все опубликованные данные о внутренностях браузера (см. [Resources](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Resources)) и провела много времени за чтением веб-страниц исходного кода браузера. Она написала:

> В годы доминирования IE 90% ничего не оставалось, кроме как рассматривать браузер как «черный ящик», но теперь, когда браузеры с открытым исходным кодом имеют [более половины доли использования](http://techcrunch.ru/2011/08/01/open-web-browser/), самое время заглянуть под капот двигателя и посмотреть, что находится внутри веб-браузера. Ну, что внутри, миллионы строк C++ ...

Тали опубликовала свое исследование на [ее сайте](http://taligarsiel.com/), но мы знали, что оно заслуживает более широкой аудитории, поэтому мы очистили его и опубликовали здесь.

Как веб-разработчик, **изучая внутренние принципы работы браузера, вы сможете принимать более правильные решения и знать причины, лежащие в основе передовых методов разработки**. Хотя это довольно длинный документ, мы рекомендуем потратить некоторое время на его изучение; мы гарантируем, что вы будете рады, что сделали. Пол Ирландский, Chrome Developer Relations

Эта статья была переведена на несколько языков: HTML5 Rocks размещает [немецкий](http://www.html5rocks.com/de/tutorials/internals/howbrowserswork/), [испанский] (http://www.html5rocks.com/es/tutorials/internals/howbrowserswork/), [японский] (http://www.html5rocks.com/ja/tutorials/internals/howbrowserswork/), [португальский] (http://www.html5rocks.com/pt/tutorials/internals/howbrowserswork/), [русский] (http://www.html5rocks.com/ru/tutorials/internals/howbrowserswork/) и [упрощенный китайский] (http://www.html5rocks.com/zh/tutorials/innerals/howbrowserswork/) версии. Вы можете просмотреть размещенные извне переводы [корейского] (http://helloworld.naver.com/helloworld/59361) и [турецкого] (http://sonsuzdongu.com/blog/tarayicilar-nasil-calisir-modern-web-tarayicilarin-perde-arkasi-cevirisi).

Вы также можете посмотреть [Тали Гарсиэль выступит с докладом на эту тему](http://vimeo.com/44182484) на Vimeo

* * *

## Вступление

Веб-браузеры являются наиболее широко используемым программным обеспечением. В этом учебнике я объясню, как они работают за кулисами. Мы увидим, что произойдет, если вы введете `google.com` в адресную строку, пока не увидите страницу Google на экране браузера.

### Оглавление

## Браузеры, о которых мы поговорим

На настольных компьютерах сегодня используются пять основных браузеров: Chrome, Internet Explorer, Firefox, Safari и Opera. На мобильных устройствах основными браузерами являются Android Browser, iPhone, Opera Mini и Opera Mobile, UC Browser, браузеры Nokia S40 / S60 и Chrome, причем все они, кроме браузеров Opera, основаны на WebKit. Я приведу примеры из браузеров с открытым исходным кодом Firefox и Chrome, а также Safari (который является частично открытым исходным кодом). Согласно [статистике StatCounter](http://gs.statcounter.com/) (по состоянию на июнь 2013 года) Chrome, Firefox и Safari составляют около 71% глобального использования настольных браузеров. На мобильных устройствах браузер Android, iPhone и Chrome составляют около 54% использования.

## Основная функциональность браузера

Основная функция браузера - представить выбранный вами веб-ресурс, запросив его у сервера и отобразив его в окне браузера. Ресурс, как правило, представляет собой HTML-документ, но также может представлять собой PDF-файл, изображение или другой тип содержимого. Местоположение ресурса указывается пользователем с помощью URI (универсального идентификатора ресурса).

То, как браузер интерпретирует и отображает файлы HTML, указано в спецификациях HTML и CSS. Эти спецификации поддерживаются организацией W3C (World Wide Web Consortium), которая является организацией стандартов для Интернета. В течение многих лет браузеры соответствовали только части спецификаций и разрабатывали собственные расширения. Это вызвало серьезные проблемы с совместимостью для веб-авторов. Сегодня большинство браузеров более или менее соответствуют спецификациям.

Пользовательские интерфейсы браузера имеют много общего друг с другом. Среди общих элементов пользовательского интерфейса:

* Адресная строка для вставки URI
* Кнопки назад и вперед
* Варианты закладок
* Обновить и остановить кнопки для обновления или остановки загрузки текущих документов
* Кнопка «Домой», которая переводит вас на домашнюю страницу

Как ни странно, пользовательский интерфейс браузера не указан ни в одной формальной спецификации, он просто основан на передовых практиках, сформировавшихся за годы опыта и подражающих друг другу браузеров. Спецификация HTML5 не определяет элементы пользовательского интерфейса, которые должен иметь браузер, но перечисляет некоторые общие элементы. Среди них адресная строка, строка состояния и панель инструментов. Разумеется, существуют уникальные функции для конкретного браузера, такого как менеджер загрузок Firefox.

## Структура высокого уровня браузера

Основные компоненты браузера: ( [1.1](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#1_1) ):

1. **Пользовательский интерфейс**: включает в себя адресную строку, кнопку «назад / вперед», меню закладок и т. Д. Каждая часть браузера отображается, кроме окна, где вы видите запрошенную страницу.
2. **Механизм браузера**: маршальные действия между пользовательским интерфейсом и механизмом рендеринга.
3. **Механизм рендеринга**: отвечает за отображение запрошенного контента. Например, если запрошенным содержимым является HTML, механизм рендеринга анализирует HTML и CSS и отображает проанализированный контент на экране.
4. **Сеть**: для сетевых вызовов, таких как HTTP-запросы, с использованием разных реализаций для разных платформ за независимым от платформы интерфейсом.
5. **Пользовательский интерфейс**: используется для рисования основных виджетов, таких как комбинированные окна и окна. Этот бэкэнд предоставляет общий интерфейс, который не зависит от платформы. Под ним используются методы пользовательского интерфейса операционной системы.
6. **Интерпретатор JavaScript**. Используется для анализа и выполнения кода JavaScript.
7. **Хранение данных**. Это постоянный слой. Браузеру может потребоваться локально сохранять все виды данных, например файлы cookie. Браузеры также поддерживают механизмы хранения, такие как localStorage, IndexedDB, WebSQL и FileSystem.

 ![](/images/7ba7cd1c25f87aa6bacc9cc57edd9689.png) 

 Рисунок: компоненты браузера

Важно отметить, что браузеры, такие как Chrome, запускают несколько экземпляров движка рендеринга: по одному для каждой вкладки. Каждая вкладка запускается в отдельном процессе.

## Рендеринг движок

Ответственность движка рендеринга - это хорошо ... Рендеринг, то есть отображение запрошенного содержимого на экране браузера.

По умолчанию механизм рендеринга может отображать HTML и XML документы и изображения. Он может отображать другие типы данных через плагины или расширения; например, отображение документов PDF с помощью плагина для просмотра PDF. Однако в этой главе мы сосредоточимся на основном сценарии использования: отображение HTML и изображений, отформатированных с помощью CSS.

## Рендеринг двигателей

Различные браузеры используют разные механизмы рендеринга: Internet Explorer использует Trident, Firefox использует Gecko, Safari использует WebKit. Chrome и Opera (с версии 15) используют Blink, форк WebKit.

WebKit - это движок с открытым исходным кодом, который был запущен как движок для платформы Linux и был изменен Apple для поддержки Mac и Windows. Смотрите [webkit.org](http://webkit.org/) для более подробной информации.

## Основной поток

Механизм рендеринга начнет получать содержимое запрошенного документа с сетевого уровня. Обычно это делается кусками по 8 КБ.

После этого это основной поток движка рендеринга:

 ![](/images/71f429bba5ef6fb7bd2221f8082ba20a.png) 

 Рисунок: рендеринг основного потока двигателя

Движок рендеринга начнет анализ HTML-документа и преобразует элементы в узлы [DOM](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#DOM) в дереве, называемом «деревом контента». Движок проанализирует данные стиля, как во внешних файлах CSS, так и в элементах стиля. Стилизация информации вместе с визуальными инструкциями в HTML будет использоваться для создания другого дерева: [рендеринга дерева](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Render_tree_construction).

Дерево рендеринга содержит прямоугольники с визуальными атрибутами, такими как цвет и размеры. Прямоугольники расположены в правильном порядке, чтобы отображаться на экране.

После построения дерева рендеринга оно проходит процесс «[layout](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#layout)». Это означает предоставление каждому узлу точных координат, где он должен появиться на экране. Следующим этапом является [painting](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Painting) - дерево рендеринга будет пройдено, и каждый узел будет окрашен с использованием внутреннего слоя пользовательского интерфейса.

Важно понимать, что это постепенный процесс. Для удобства пользователей механизм рендеринга попытается отобразить содержимое на экране как можно скорее. Он не будет ждать до тех пор, пока весь HTML не будет проанализирован, прежде чем начать сборку и компоновку дерева рендеринга. Части содержимого будут проанализированы и отображены, в то время как процесс продолжается с остальным содержимым, которое продолжает поступать из сети.

### Примеры основного потока

 ![](/images/85a66640e7f1d9b94421884d454cad12.png) 

 Рисунок: основной поток WebKit

 ![](/images/b074db49562b1d3d2416c22b624c574b.jpg) 

 Рисунок: основной поток движка рендеринга Gezo в Mozilla ( [3.6](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#3_6) )

Из рисунков 3 и 4 видно, что хотя WebKit и Gecko используют несколько различную терминологию, процесс в основном одинаков.

Gecko называет дерево визуально отформатированных элементов «рамочным деревом». Каждый элемент - это рамка. WebKit использует термин «Render Tree» и состоит из «Render Objects». WebKit использует термин «макет» для размещения элементов, в то время как Gecko называет его «Reflow». «Вложение» - это термин WebKit для соединения узлов DOM и визуальной информации для создания дерева рендеринга. Небольшое несемантическое отличие состоит в том, что у Gecko есть дополнительный слой между HTML и деревом DOM. Он называется «приемником контента» и является фабрикой для создания элементов DOM. Мы поговорим о каждой части потока:

### Парсинг–общие

Поскольку синтаксический анализ является очень важным процессом в механизме рендеринга, мы углубимся в него. Давайте начнем с небольшого введения о разборе.

Разбор документа означает перевод его в структуру, которую может использовать код. Результатом синтаксического анализа обычно является дерево узлов, которые представляют структуру документа. Это называется деревом разбора или синтаксическим деревом.

Например, синтаксический анализ выражения 2 + 3 - 1 может вернуть это дерево:

 ![](/images/bc20d504cc8b45e7a4a8d99cab39019e.png) 

 Рисунок: узел дерева математических выражений

### Грамматика

Синтаксический анализ основан на правилах синтаксиса, которым подчиняется документ: на языке или формате, в котором он был написан. Каждый формат, который вы можете анализировать, должен иметь детерминированную грамматику, состоящую из словарных и синтаксических правил. Это называется [контекстно-свободной грамматикой](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#context_free_grammar). Человеческие языки не являются такими языками и поэтому не могут быть проанализированы с помощью обычных методов анализа.

### Комбинация парсер-лексер

Разбор может быть разделен на два подпроцесса: лексический анализ и синтаксический анализ.

Лексический анализ - это процесс взлома входных данных на токены. Токены - это словарь языка: коллекция действительных строительных блоков. На человеческом языке он будет состоять из всех слов, которые появляются в словаре для этого языка.

Синтаксический анализ - это применение правил синтаксиса языка.

Синтаксические анализаторы обычно делят работу между двумя компонентами: **лексер** (иногда называемый токенизатором), который отвечает за разбиение входных данных на допустимые токены, и **парсер**, который отвечает за построение дерева синтаксического анализа путем анализа документа. структура в соответствии с правилами синтаксиса языка. Лексер знает, как убрать нерелевантные символы, такие как пробелы и разрывы строк.

 ![](/images/175e3c1dd7246701c39c7ad7f841ddc4.png) 

 Рисунок: из исходного документа для разбора деревьев

Процесс разбора является итеративным. Парсер обычно запрашивает у лексера новый токен и пытается сопоставить токен с одним из правил синтаксиса. Если правило соответствует, узел, соответствующий токену, будет добавлен в дерево разбора, и анализатор запросит другой токен.

Если ни одно из правил не соответствует, анализатор будет хранить токен внутри и продолжать запрашивать токены до тех пор, пока не будет найдено правило, соответствующее всем внутренне сохраненным токенам. Если правила не найдены, парсер вызовет исключение. Это означает, что документ был недействительным и содержал синтаксические ошибки.

### Перевод

Во многих случаях дерево разбора не является конечным продуктом. При переводе часто используется синтаксический анализ: преобразование входного документа в другой формат. Примером является компиляция. Компилятор, который компилирует исходный код в машинный код, сначала анализирует его в дереве разбора, а затем переводит дерево в документ машинного кода.

 ![](/images/adedd28fadec708cb4e0c8dd5d24448c.png) 

 Рисунок: компиляция

### Пример разбора

На рисунке 5 мы построили дерево разбора из математического выражения. Давайте попробуем определить простой математический язык и посмотрим процесс разбора.

Словарь: Наш язык может включать в себя целые числа, знаки плюс и минус.

Синтаксис:

1. Строительными блоками синтаксиса языка являются выражения, термины и операции.
2. Наш язык может включать любое количество выражений.
3. Выражение определяется как «термин», за которым следует «операция», за которой следует другой термин
4. Операция является плюсом или минусом
5. Термин - это целочисленный токен или выражение

Давайте проанализируем входные данные 2 + 3 - 1.
Первая подстрока, которая соответствует правилу - это 2: согласно правилу № 5 это термин. Второе совпадение - 2 + 3: это соответствует третьему правилу: термин, за которым следует операция, за которой следует другой термин. Следующее совпадение будет выполнено только в конце ввода. 2 + 3 - 1 - это выражение, потому что мы уже знаем, что 2 + 3 - это термин, поэтому у нас есть термин, за которым следует операция, за которой следует другой термин. 2 + + не будет соответствует любому правилу и поэтому является неверным вводом.

### Формальные определения для словаря и синтаксиса

Словарь обычно выражается [регулярными выражениями](http://www.regular-expressions.info/).

Например, наш язык будет определен как:

```
INTEGER: 0|[1-9][0-9]*
PLUS: +
MINUS: -
```

Как видите, целые числа определяются регулярным выражением.

Синтаксис обычно определяется в формате, который называется [BNF](http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form). Наш язык будет определен как:

```
expression :=  term  operation  term
operation :=  PLUS | MINUS
term := INTEGER | expression
```

Мы сказали, что язык может быть проанализирован обычными синтаксическими анализаторами, если его грамматика не содержит текстовой грамматики. Интуитивно понятное определение контекстно-свободной грамматики - это грамматика, которая может быть полностью выражена в BNF. Формальное определение см. В статье Википедии по контекстно-свободной грамматике (http://en.wikipedia.org/wiki/Context-free_grammar).

### Типы парсеров

Есть два типа парсеров: парсеры сверху вниз и парсеры снизу вверх. Интуитивно понятное объяснение состоит в том, что синтаксические анализаторы сверху вниз изучают структуру синтаксиса высокого уровня и пытаются найти соответствие правилу. Анализаторы снизу вверх начинаются с ввода и постепенно преобразуют его в правила синтаксиса, начиная с правил низкого уровня и заканчивая соблюдением правил высокого уровня.

Давайте посмотрим, как два типа парсеров будут анализировать наш пример.

Анализатор сверху вниз будет начинаться с правила более высокого уровня: он будет определять 2 + 3 как выражение. Затем он идентифицирует 2 + 3 - 1 как выражение (процесс идентификации выражения развивается в соответствии с другими правилами, но начальная точка - это правило самого высокого уровня).

Анализатор снизу вверх будет сканировать ввод, пока не будет найдено правило. Затем он заменит соответствующий ввод правилом. Это будет продолжаться до конца ввода. Частично сопоставленное выражение помещается в стек анализатора.

| Stack | Input |
| --- | --- |
|   | 2 + 3 - 1 |
| term | \+ 3 - 1 |
| term operation | 3 - 1 |
| expression | \- 1 |
| expression operation | 1 |
| expression | \- |

Этот тип анализатора снизу вверх называется анализатором сдвига-уменьшения, потому что ввод смещен вправо (представьте указатель, указывающий сначала в начале ввода и перемещающийся вправо) и постепенно сводится к правилам синтаксиса.

### Генерация парсеров автоматически

Есть инструменты, которые могут генерировать парсер. Вы кормите им грамматику вашего языка - его словарный запас и синтаксические правила - и они генерируют работающий синтаксический анализатор. Создание парсера требует глубокого понимания синтаксического анализа, и создать оптимизированный парсер вручную непросто, поэтому генераторы парсеров могут быть очень полезны.

WebKituses два хорошо известных генератора парсеров: [Flex](http://en.wikipedia.org/wiki/Flex_lexical_analyser) для создания лексера и [Bison](http://www.gnu.org/software/bison/) для создания парсера (вы можете столкнуться с ними с именами Lex и Yacc). Flex input - это файл, содержащий регулярные выражения для определения токенов. Ввод Bison - это правила синтаксиса языка в формате BNF.

## HTML Parser

Работа синтаксического анализатора HTML заключается в том, чтобы анализировать разметку HTML в дереве разбора.

### Определение грамматики HTML

Словарь и синтаксис HTML определены в [спецификациях](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#w3c), созданных организацией W3C.

### Не контекстно-свободная грамматика

Как мы видели во введении синтаксического анализа, синтаксис грамматики может быть определен формально с использованием таких форматов, как BNF.

К сожалению, все обычные темы синтаксического анализа не относятся к HTML (я не приводил их просто для удовольствия - они будут использоваться при разборе CSS и JavaScript). HTML не может быть легко определен грамматикой без контекста, которая нужна анализаторам.

Существует формальный формат для определения HTML - DTD (определение типа документа) - но это не контекстно-свободная грамматика.

Это кажется странным на первый взгляд; HTML довольно близок к XML. Есть много доступных парсеров XML. Существует XML-вариант HTML - XHTML - так в чем же большая разница?

Разница в том, что подход HTML более «прощающий»: он позволяет вам опустить определенные теги (которые затем добавляются неявно), или иногда пропустить начальный или конечный теги и т. Д. В целом, это «мягкий» синтаксис, в отличие от жесткого и требовательного синтаксиса XML.

Эта, казалось бы, маленькая деталь делает мир другим. С одной стороны, это главная причина популярности HTML: он прощает ваши ошибки и облегчает жизнь веб-авторам. С другой стороны, это затрудняет написание формальной грамматики. Подводя итог, можно сказать, что HTML не может быть легко проанализирован обычными синтаксическими анализаторами, поскольку его грамматика не является контекстно-свободной. HTML не может быть проанализирован анализаторами XML.

### HTML DTD

Определение HTML в формате DTD. Этот формат используется для определения языков семейства [SGML](http://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language). Формат содержит определения для всех разрешенных элементов, их атрибутов и иерархии. Как мы видели ранее, HTML DTD не формирует грамматику без контекста.

Есть несколько вариантов DTD. Строгий режим соответствует только спецификациям, но другие режимы содержат поддержку разметки, используемой браузерами в прошлом. Цель - обратная совместимость со старым контентом. Текущий строгий DTD находится здесь: [www.w3.org/TR/html4/strict.dtd](http://www.w3.org/TR/html4/strict.dtd)

### DOM

Выходное дерево ("дерево разбора") - это дерево элементов DOM и узлов атрибутов. DOM - это сокращение от объектной модели документа. Это объектное представление документа HTML и интерфейс элементов HTML с внешним миром, таким как JavaScript.
Корнем дерева является объект «[Document](http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document)».

DOM имеет почти однозначное отношение к разметке. Например:

```html
<html>
  <body>
    <p>
      Hello World
    </p>
    <div> <img src="example.png"/></div>
  </body>
</html>
```

Эта разметка будет переведена в следующее дерево DOM:

 ![](/images/16ef855a130014986eef5af91304b3a0.png) 

 Рисунок: DOM-дерево примера разметки

Как и HTML, DOM определяется организацией W3C. См. [Www.w3.org/DOM/DOMTR](http://www.w3.org/DOM/DOMTR). Это общая спецификация для работы с документами. Определенный модуль описывает специфические элементы HTML. Определения HTML можно найти здесь: [www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html](http://www.w3.org/TR/ 2003 / REC-DOM-Level-2-HTML-20030109 / idl-definitions.html).

Когда я говорю, что дерево содержит узлы DOM, я имею в виду, что дерево состоит из элементов, которые реализуют один из интерфейсов DOM. Браузеры используют конкретные реализации, которые имеют другие атрибуты, используемые браузером внутри.

#### Алгоритм разбора

Как мы видели в предыдущих разделах, HTML не может быть проанализирован с помощью обычного анализатора сверху вниз или снизу вверх.

Причины:

1. Прощающая природа языка.
2. Тот факт, что браузеры имеют традиционную устойчивость к ошибкам для поддержки хорошо известных случаев недопустимого HTML.
3. Процесс разбора реентерабельный. Для других языков источник не изменяется во время синтаксического анализа, но в HTML динамический код (например, элементы скрипта, содержащие вызовы `document.write()`) может добавлять дополнительные токены, поэтому процесс синтаксического анализа фактически изменяет ввод.

Невозможно использовать обычные методы синтаксического анализа, браузеры создают собственные парсеры для анализа HTML.

[Алгоритм разбора подробно описан в спецификации HTML5](http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html). Алгоритм состоит из двух этапов: токенизация и построение дерева.

Токенизация - это лексический анализ, разбирающий входные данные в токены. К HTML-токенам относятся начальные теги, конечные теги, имена атрибутов и значения атрибутов.

Токенайзер распознает токен, передает его конструктору дерева и использует следующий символ для распознавания следующего токена и т. Д. До конца ввода.

 ![](/images/618a32b45bea0ca79c36309579c8dedb.png) 

 Рисунок: поток синтаксического анализа HTML (взят из спецификации HTML5)

### Алгоритм токенизации

Вывод алгоритма - это HTML-токен. Алгоритм выражается как конечный автомат. Каждое состояние потребляет один или несколько символов входного потока и обновляет следующее состояние в соответствии с этими символами. Решение зависит от текущего состояния токенизации и состояния построения дерева. Это означает, что один и тот же потребляемый символ даст разные результаты для правильного следующего состояния, в зависимости от текущего состояния. Алгоритм слишком сложен, чтобы описать его полностью, поэтому давайте рассмотрим простой пример, который поможет нам понять принцип.

Базовый пример - токенизация следующего HTML:

```html
<html>
  <body>
    Hello world
  </body>
</html>
```

Начальное состояние - «Состояние данных». Когда встречается символ `<`, состояние изменяется на **«Открытое состояние тега»**. Использование символа `a-z` приводит к созданию "маркера начального тега", состояние изменяется на **"Состояние имени тега"**. Мы остаемся в этом состоянии, пока символ `>` не будет уничтожен. Каждый символ добавляется к новому имени токена. В нашем случае созданный токен является html-токеном.

При достижении тега `>` текущий токен испускается, и состояние изменяется обратно на **"Состояние данных"**. Тег \<body> будет обработан теми же шагами. До сих пор были созданы теги `html` и `body`. Теперь мы вернулись к **«состоянию данных»**. Использование символа `H` `Hello world` приведет к созданию и испусканию токена символа, это продолжается до тех пор, пока не будет достигнуто `<` of `</ body>`. Мы будем выдавать символьный токен для каждого символа «Hello world».

Теперь мы вернулись в **«Открытое состояние тега»**. Потребление следующего ввода `/` вызовет создание `токена конечного тега` и перехода в **"состояние имени тега"**. Мы снова остаемся в этом состоянии до тех пор, пока не достигнем `>`. После этого будет выдан токен нового тега, и мы вернемся к **«состоянию данных»**. Входные данные `</ html>` будут обрабатываться так же, как и в предыдущем случае.

 ![](/images/dbf0664153ac609ac61b0f32bb099f23.png) 

 Рисунок: токенизация входных данных примера

#### Алгоритм построения дерева

Когда парсер создан, объект Document создается. На этапе построения дерева дерево DOM с Документом в корне будет изменено, и к нему будут добавлены элементы. Каждый узел, испускаемый токенизатором, будет обрабатываться конструктором дерева. Для каждого токена спецификация определяет, какой элемент DOM имеет к нему отношение и будет создан для этого токена. Элемент добавляется в дерево DOM, а также в стек открытых элементов. Этот стек используется для исправления несоответствий вложенности и незакрытых тегов. Алгоритм также описывается как конечный автомат. Состояния называются «режимами вставки».

Давайте посмотрим процесс построения дерева для примера ввода:

```html
<html>
  <body>
    Hello world
  </body>
</html>
```

Входом на этапе построения дерева является последовательность токенов из этапа токенизации. Первый режим - это **«начальный режим»(initial mode)**. Получение токена "html" приведет к переходу в режим **"before html"** и повторной обработке токена в этом режиме. Это приведет к созданию элемента HTMLHtmlElement, который будет добавлен к корневому объекту Document.

Состояние будет изменено на **"before head"**. Токен "body" тогда получен. HTMLHeadElement будет создан неявно, хотя у нас нет токена «head», и он будет добавлен в дерево.

Теперь мы переходим в режим **«in head»**, а затем в **«after head»**. Токен тела перерабатывается, создается и вставляется HTMLBodyElement, а режим переносится в **"in body"**.

Токены символов строки "Hello world" теперь получены. Первый вызовет создание и вставку узла «Текст», а другие символы будут добавлены к этому узлу.

Получение маркера конца тела приведет к переходу в режим **«after body»**. Теперь мы получим html end tag, который переместит нас в режим **"after after body"**. Получение маркера конца файла прекратит синтаксический анализ.

 ![](/images/5d647d69fde4ee3e3fbca60eb319c8b3.gif) 

 Рисунок: построение дерева примера html

### Действия, когда разбор завершен

На этом этапе браузер помечает документ как интерактивный и запускает сценарии синтаксического анализа, которые находятся в «отложенном» режиме: те, которые должны быть выполнены после анализа документа. Состояние документа будет затем установлено на «завершено» и будет запущено событие «загрузить».

Вы можете увидеть [полные алгоритмы токенизации и построения дерева в спецификации HTML5](http://www.w3.org/TR/html5/syntax.html#html-parser) 

### Ошибка браузеров

Вы никогда не получите ошибку «Неверный синтаксис» на странице HTML. Браузеры исправляют любой недействительный контент и продолжают.

Возьмите этот HTML, например:

```html
<html>
  <mytag>
  </mytag>
  <div>
  <p>
  </div>
    Really lousy HTML
  </p>
</html>
```

Должно быть, я нарушил около миллиона правил («mytag» - это не стандартный тег, неправильное вложение элементов «p» и «div» и т. Д.), Но браузер все равно показывает это правильно и не жалуется. Поэтому большая часть кода парсера исправляет ошибки автора HTML.

Обработка ошибок довольно стабильна в браузерах, но, что удивительно, она не была частью спецификаций HTML. Как закладки, так и кнопки назад / вперед, это то, что разрабатывалось в браузерах на протяжении многих лет. Известны недопустимые конструкции HTML, повторяющиеся на многих сайтах, и браузеры пытаются исправить их способом, совместимым с другими браузерами.

Спецификация HTML5 действительно определяет некоторые из этих требований. (WebKit хорошо описывает это в комментарии в начале класса HTML-анализатора.)

> Синтаксический анализатор анализирует токенизированный ввод в документ, формируя дерево документа. Если документ правильно сформирован, его анализ выполняется просто.
>
> К сожалению, нам приходится обрабатывать многие HTML-документы, которые не являются правильно сформированными, поэтому анализатор должен быть терпимым к ошибкам.
>
> Мы должны позаботиться как минимум о следующих условиях ошибки:
>
> 1. Добавляемый элемент явно запрещен внутри какого-либо внешнего тега. В этом случае мы должны закрыть все теги до того, который запрещает элемент, и добавить его впоследствии.
> 2. Нам не разрешено добавлять элемент напрямую. Может случиться так, что человек, пишущий документ, забыл какой-то тег между ними (или что тег между ними необязателен). Это может быть в случае со следующими тегами: HTML HEAD BODY TBODY TR TD LI (я забыл что-нибудь?).
> 3. Мы хотим добавить блочный элемент внутри встроенного элемента. Закройте все встроенные элементы до следующего более высокого элемента блока.
> 4. Если это не помогает, закрывайте элементы, пока нам не разрешат добавить элемент - или игнорируйте тег.

Давайте посмотрим несколько примеров устойчивости к ошибкам WebKit:

#### \</br> вместо \<br>

Некоторые сайты используют \</br> вместо \<br>. Чтобы быть совместимым с IE и Firefox, WebKit обрабатывает это как \<br>.
Код:

```c++
if (t->isCloseTag(brTag) && m\_document->inCompatMode()) {
     reportError(MalformedBRError);
     t->beginTag = true;
}
```

Обратите внимание, что обработка ошибок является внутренней: она не будет представлена пользователю.

#### Блочная таблица

Блочная таблица - это таблица внутри другой таблицы, но не внутри ячейки таблицы.

Например:

```html
<table>
    <table>
        <tr><td>inner table</td></tr>
    </table>
    <tr><td>outer table</td></tr>
</table>
```

WebKit изменит иерархию до двух родственных таблиц:

```html
<table>
    <tr><td>outer table</td></tr>
</table>
<table>
    <tr><td>inner table</td></tr>
</table>
```

Код:

```c++
if (m_inStrayTableContent && localName == tableTag)
        popBlock(tableTag);
```

WebKit использует стек для текущего содержимого элемента: он извлекает внутреннюю таблицу из стека внешней таблицы. Столы теперь будут братьями и сестрами.

#### Вложенные элементы формы

Если пользователь помещает форму внутри другой формы, вторая форма игнорируется.
Код:

```c++
if (!m_currentFormElement) {
        m_currentFormElement = new HTMLFormElement(formTag, m_document);
}
```

#### Слишком глубокая иерархия тегов

Комментарий говорит сам за себя.  

> www.liceo.edu.mx пример сайта, который достигает уровня вложенности около 1500 тегов, и все это из группы \<b>. Мы допустим не более 20 вложенных тегов одного типа, прежде чем просто игнорировать их все вместе.

```c++
bool HTMLParser::allowNestedRedundantTag(const AtomicString& tagName)
{

unsigned i = 0;
for (HTMLStackElem* curr = m\_blockStack;
         i < cMaxRedundantTagDepth && curr && curr->tagName == tagName;
     curr = curr->next, i++) { }
return i != cMaxRedundantTagDepth;
}
```
	
#### Неуместные теги html или end
	
Опять же - комментарий говорит сам за себя.

> Поддержка действительно сломанного HTML. Мы никогда не закрываем тег body, поскольку некоторые глупые веб-страницы закрывают его до фактического конца документа. Давайте полагаться на вызов end(), чтобы закрыть вещи.

```c++
if (t->tagName == htmlTag || t->tagName == bodyTag )
        return;
```
	
Так что веб-разработчики остерегаются - если вы не хотите появиться в качестве примера в фрагменте кода устойчивости к ошибкам WebKit - пишите правильно сформированный HTML.

## CSS-разбор

Помните концепции разбора во введении? Ну, в отличие от HTML, CSS является контекстно-свободной грамматикой и может быть проанализирован с использованием типов синтаксических анализаторов, описанных во введении. Фактически [спецификация CSS определяет лексическую и синтаксическую грамматику CSS](http://www.w3.org/TR/CSS2/grammar.html).

Давайте посмотрим несколько примеров:
Лексическая грамматика (словарь) определяется регулярными выражениями для каждого токена:

```
comment   \\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\/
num   [0-9]+|[0-9]*"."[0-9]+
nonascii  [\\200-\\377]
nmstart   [_a-z]|{nonascii}|{escape}
nmchar    [_a-z0-9-]|{nonascii}|{escape}
name    {nmchar}+
ident   {nmstart}{nmchar}*
```
	
«идентификатор» - это сокращение от идентификатора, например, имя класса. «name» - это идентификатор элемента (на который указывает «#»)

Синтаксическая грамматика описана в BNF.

```
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
selector
  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?
  ;
simple_selector
  : element_name [ HASH | class | attrib | pseudo ]*
  | [ HASH | class | attrib | pseudo ]+
  ;
class
  : '.' IDENT
  ;
element_name
  : IDENT | '*'
  ;
attrib
  : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
    [ IDENT | STRING ] S* ] ']'
  ;
pseudo
  : ':' [ IDENT | FUNCTION S* [IDENT S*] ')' ]
  ;
```
	
Пояснение: набор правил - это структура:

```css
div.error, a.error {
  color:red;
  font-weight:bold;
}
```
	
div.error и a.error являются селекторами. Часть внутри фигурных скобок содержит правила, которые применяются этим набором правил. Эта структура определена формально в этом определении:

```	
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
```
	
Это означает, что набор правил представляет собой селектор или, необязательно, ряд селекторов, разделенных запятой и пробелами (S обозначает пробел). Набор правил содержит фигурные скобки и внутри них объявление или, необязательно, несколько объявлений, разделенных точкой с запятой. «объявление» и «селектор» будут определены в следующих определениях BNF.

### WebKit CSS-парсер

WebKit использует генераторы парсеров [Flex and Bison](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#parser_generators) для автоматического создания парсеров из файлов грамматики CSS. Как вы помните из введения парсера, Bison создает синтаксический анализатор с восходящим сдвигом снизу вверх. Firefox использует анализатор сверху вниз, написанный вручную. В обоих случаях каждый файл CSS анализируется в объекте StyleSheet. Каждый объект содержит правила CSS. Объекты правил CSS содержат объекты селекторов и объявлений, а также другие объекты, соответствующие грамматике CSS.

 ![](/images/0aa927e9313bf58eb4a12f5ce2c014f5.png) 

 Рисунок: разбор CSS

## Порядок обработки скриптов и таблиц стилей

#### Сценарии

Модель сети является синхронной. Авторы ожидают, что сценарии будут проанализированы и выполнены немедленно, когда синтаксический анализатор достигнет тега \<script>. Разбор документа останавливается до тех пор, пока скрипт не будет выполнен. Если скрипт является внешним, то ресурс должен сначала быть выбран из сети - это также делается синхронно, и анализ останавливается, пока ресурс не будет выбран. Это была модель на протяжении многих лет, а также указано в спецификациях HTML4 и 5. Авторы могут добавить атрибут «defer» в скрипт, и в этом случае он не остановит синтаксический анализ документа и выполнится после анализа документа. HTML5 добавляет опцию, чтобы пометить скрипт как асинхронный, чтобы он был проанализирован и выполнен другим потоком.

### Умозрительный разбор

И WebKit, и Firefox делают эту оптимизацию. При выполнении сценариев другой поток анализирует остальную часть документа и выясняет, какие другие ресурсы необходимо загрузить из сети, и загружает их. Таким образом, ресурсы могут быть загружены через параллельные соединения, и общая скорость улучшена. Примечание: спекулятивный парсер анализирует только ссылки на внешние ресурсы, такие как внешние скрипты, таблицы стилей и изображения: он не изменяет дерево DOM, оставленное основному парсеру.

### Таблицы стилей

С другой стороны, таблицы стилей имеют другую модель. Концептуально кажется, что, поскольку таблицы стилей не изменяют дерево DOM, нет причин ждать их и останавливать анализ документа. Однако существует проблема сценариев, запрашивающих информацию о стиле на этапе анализа документа. Если стиль еще не загружен и не проанализирован, скрипт получит неправильные ответы, и, очевидно, это вызвало много проблем. Вроде бы крайний случай, но довольно распространенный. Firefox блокирует все сценарии, когда есть таблица стилей, которая все еще загружается и анализируется. WebKit блокирует сценарии только тогда, когда они пытаются получить доступ к определенным свойствам стиля, на которые могут повлиять выгруженные таблицы стилей.

## Построение дерева визуализации

Пока дерево DOM создается, браузер создает другое дерево - дерево рендеринга. Это дерево имеет визуальные элементы в том порядке, в котором они будут отображаться. Это визуальное представление документа. Назначение этого дерева - сделать так, чтобы содержимое отображалось в правильном порядке.

Firefox называет элементы в дереве рендеринга «кадрами». WebKit использует термин рендерер или объект рендеринга.
Рендерер знает, как выложить и нарисовать себя и своих детей.
Класс RenderObject WebKit, базовый класс средств визуализации, имеет следующее определение:

```c++
class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;  //the DOM node
  RenderStyle* style;  // the computed style
  RenderLayer* containgLayer; //the containing z-index layer
}
```
	
Каждый визуализатор представляет прямоугольную область, обычно соответствующую блоку CSS узла, как описано в спецификации CSS2. Он включает в себя геометрическую информацию, такую как ширина, высота и положение.
На тип блока влияет значение «display» атрибута style, относящегося к узлу (см. [Вычисление стиля](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#style_computation) раздел). Вот код WebKit для решения, какой тип средства визуализации должен быть создан для узла DOM, в соответствии с атрибутом display:

```c++
RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
    Document* doc = node->document();
    RenderArena* arena = doc->renderArena();
    ...
    RenderObject* o = 0;

    switch (style->display()) {
        case NONE:
            break;
        case INLINE:
            o = new (arena) RenderInline(node);
            break;
        case BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case INLINE_BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case LIST_ITEM:
            o = new (arena) RenderListItem(node);
            break;
       ...
    }

    return o;
}
```
	
Тип элемента также учитывается: например, элементы управления формы и таблицы имеют специальные фреймы.
В WebKit, если элемент хочет создать специальный рендерер, он переопределит метод `createRenderer()`. Средства визуализации указывают на объекты стиля, которые содержат не геометрическую информацию.

### Отношение дерева рендеринга к дереву DOM

Средства визуализации соответствуют элементам DOM, но отношение не один к одному. Невизуальные элементы DOM не будут вставлены в дерево визуализации. Примером является элемент «head». Также элементы, значение display которых было присвоено «none», не будут отображаться в дереве (тогда как элементы со «скрытой» видимостью будут отображаться в дереве).

Есть элементы DOM, которые соответствуют нескольким визуальным объектам. Обычно это элементы со сложной структурой, которые нельзя описать одним прямоугольником. Например, элемент «select» имеет три средства визуализации: один для области отображения, один для раскрывающегося списка и один для кнопки. Также, когда текст разбит на несколько строк, поскольку ширина не достаточна для одной строки, новые строки будут добавлены в качестве дополнительных средств визуализации.
Другим примером нескольких рендеров является битый HTML. Согласно спецификации CSS встроенный элемент должен содержать либо только блочные элементы, либо только встроенные элементы. В случае смешанного контента будут созданы анонимные средства визуализации блоков, чтобы обернуть встроенные элементы.

Некоторые объекты рендеринга соответствуют узлу DOM, но не находятся в одном и том же месте дерева. Поплавки и абсолютно позиционированные элементы находятся вне потока, размещаются в другой части дерева и отображаются в реальный фрейм. Рамка-заполнитель - это место, где они должны были быть.

 ![](/images/a43a99a924a135f54b9ccd937b6c5de5.png) 

 Рисунок: дерево рендеринга и соответствующее дерево DOM ( [3.1](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#3_1) ). «Окно просмотра» - это начальный содержащий блок. В WebKit это будет объект "RenderView"

#### Поток построения дерева

В Firefox презентация регистрируется как слушатель обновлений DOM. Презентация делегирует создание фрейма в FrameConstructor, а конструктор разрешает стиль (см. [Вычисление стиля](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#style)) и создает фрейм.

В WebKit процесс определения стиля и создания рендерера называется «вложением». Каждый узел DOM имеет метод присоединения. Присоединение происходит синхронно, вставка узла в дерево DOM вызывает новый метод присоединения узла.

Обработка тегов html и body приводит к построению корня дерева рендеринга. Корневой объект рендеринга соответствует тому, что спецификация CSS называет содержащим блоком: самый верхний блок, который содержит все остальные блоки. Его размеры - область просмотра: размеры области отображения окна браузера. Firefox называет его `ViewPortFrame`, а WebKit называет его `RenderView`. Это объект рендеринга, на который указывает документ. Остальная часть дерева построена как вставка узлов DOM.

См. [Спецификацию CSS2 для модели обработки] (http://www.w3.org/TR/CSS21/intro.html#processing-model).

### Вычисление стиля

Построение дерева рендеринга требует вычисления визуальных свойств каждого объекта рендеринга. Это делается путем расчета свойств стиля каждого элемента.

Стиль включает в себя таблицы стилей различного происхождения, встроенные элементы стиля и визуальные свойства в HTML (например, свойство "bgcolor"). Позднее переводится в соответствующие свойства стиля CSS.

Источниками таблиц стилей являются таблицы стилей браузера по умолчанию, таблицы стилей, предоставленные автором страницы, и таблицы стилей пользователя - это таблицы стилей, предоставленные пользователем браузера (браузеры позволяют вам определять ваши любимые стили. Например, в Firefox, это можно сделать, поместив таблицу стилей в папку «Профиль Firefox»).

Вычисление стиля поднимает несколько трудностей:

1. Styledata - очень большая конструкция, содержащая многочисленные свойства стиля, это может вызвать проблемы с памятью.
2. Поиск правил соответствия для каждого элемента может вызвать проблемы с производительностью, если он не оптимизирован. Обходить весь список правил для каждого элемента, чтобы найти совпадения, является тяжелой задачей. Селекторы могут иметь сложную структуру, которая может привести к тому, что процесс сопоставления начнется на кажущемся многообещающем пути, который оказался бесполезным, и нужно искать другой путь.
    
Например, этот составной селектор:
    
```css
    div div div div{
      ...
    }
```
    
Означает, что правила применяются к `<div>`, который является потомком 3 div. Предположим, вы хотите проверить, применяется ли правило для данного элемента `<div>`. Вы выбираете определенный путь вверх по дереву для проверки. Возможно, вам придется пройтись по дереву узлов, чтобы выяснить, что есть только два элемента div, и правило не применяется. Затем вам нужно попробовать другие пути в дереве.
3. Применение правил предполагает довольно сложные каскадные правила, которые определяют иерархию правил.

Давайте посмотрим, как браузеры сталкиваются с этими проблемами:

### Обмен стилем данных

Узлы WebKit ссылаются на объекты стиля (RenderStyle). Эти объекты могут совместно использоваться узлами в некоторых условиях. Узлы являются братьями и сестрами или двоюродными братьями и:

1. Элементы должны находиться в одном и том же состоянии мыши (например, один не может быть в :hover, а другой нет)
2. Ни один элемент не должен иметь идентификатор
3. Имена тегов должны совпадать
4. Атрибуты класса должны совпадать
5. Набор отображаемых атрибутов должен быть идентичным
6. Состояния ссылки должны совпадать
7. Фокусные состояния должны совпадать
8. Ни один из элементов не должен зависеть от селекторов атрибутов, где он определяется как наличие любого селектора, который использует селектор атрибута в любой позиции в селекторе вообще.
9. На элементах не должно быть встроенного атрибута стиля.
10. Не должно быть никаких использованных селекторов. WebCore просто генерирует глобальный переключатель, когда встречается любой селектор, и отключает совместное использование стилей для всего документа, когда они присутствуют. Это включает в себя селектор + и селекторы, такие как: first-child и: last-child.

### Дерево правил Firefox

Firefox имеет два дополнительных дерева для более удобного вычисления стиля: дерево правил и дерево контекста стиля. В WebKit также есть объекты стилей, но они не хранятся в дереве, подобном дереву контекста стиля, только узел DOM указывает на соответствующий стиль.

 ![](/images/72c59985cb28271820cda8d2f837af4f.png) 

 Рисунок: контекстное дерево стиля Firefox( [2.2](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#2_2) )

Контексты стиля содержат конечные значения. Значения вычисляются путем применения всех правил сопоставления в правильном порядке и выполнения манипуляций, которые преобразуют их из логических в конкретные значения. Например, если логическое значение представляет собой процент экрана, оно будет рассчитано и преобразовано в абсолютные единицы. Идея дерева правил действительно умная. Это позволяет разделять эти значения между узлами, чтобы избежать их повторного вычисления. Это также экономит место.

Все соответствующие правила хранятся в дереве. Нижние узлы в пути имеют более высокий приоритет. Дерево содержит все пути для найденных совпадений правил. Хранение правил делается лениво. Дерево не рассчитывается в начале для каждого узла, но всякий раз, когда необходимо вычислить стиль узла, вычисленные пути добавляются в дерево.

Идея состоит в том, чтобы видеть пути деревьев как слова в лексиконе. Допустим, мы уже вычислили это дерево правил:

 ![](/images/6f9fc4959f0df56584840b047c8d6724.png) 

Предположим, нам нужно сопоставить правила для другого элемента в дереве содержимого и выяснить, соответствуют ли правила (в правильном порядке) B-E-I. У нас уже есть этот путь в дереве, потому что мы уже вычислили путь A-B-E-I-L. Теперь у нас будет меньше работы.

Посмотрим, как дерево спасает нас от работы.

### Деление на структуры

Стили контекстов делятся на структуры. Эти структуры содержат информацию о стиле для определенной категории, например границы или цвета. Все свойства в структуре либо наследуются, либо не наследуются. Унаследованные свойства - это свойства, которые, если они не определены элементом, наследуются от его родителя. Не унаследованные свойства (называемые свойствами «reset») используют значения по умолчанию, если они не определены.

Дерево помогает нам, кэшируя целые структуры (содержащие вычисленные конечные значения) в дереве. Идея состоит в том, что если нижний узел не предоставил определение для структуры, можно использовать кэшированную структуру в верхнем узле.

### Вычисление контекстов стиля с использованием дерева правил

При вычислении контекста стиля для определенного элемента мы сначала вычисляем путь в дереве правил или используем существующий. Затем мы начинаем применять правила в пути, чтобы заполнить структуры в нашем новом стилевом контексте. Мы начинаем с нижнего узла пути - того, который имеет наивысший приоритет (обычно самый специфический селектор) и пересекаем дерево до тех пор, пока наша структура не заполнится. Если в этом узле правила нет спецификации для структуры, то мы можем значительно оптимизировать - мы идем вверх по дереву, пока не найдем узел, который полностью его определяет, и просто укажем на него - это лучшая оптимизация - вся структура является общей. Это сохраняет вычисления конечных значений и памяти.
Если мы находим частичные определения, мы поднимаемся по дереву, пока структура не будет заполнена.

Если мы не нашли никаких определений для нашей структуры, тогда, если структура является «унаследованным» типом, мы указываем на структуру нашего родителя в **контекстном дереве**. В этом случае нам также удалось поделиться структурами. Если это структура сброса, то будут использоваться значения по умолчанию.

Если наиболее конкретный узел добавляет значения, нам нужно выполнить некоторые дополнительные вычисления для преобразования его в фактические значения. Затем мы кешируем результат в узле дерева, чтобы его могли использовать дети.

Если у элемента есть брат или брат, который указывает на один и тот же узел дерева, тогда **весь контекст стиля** может быть разделен между ними.

Давайте посмотрим пример: предположим, у нас есть этот HTML

```html
<html>
  <body>
    <div class="err" id="div1">
      <p>
        this is a <span class="big"> big error </span>
        this is also a
        <span class="big"> very  big  error</span> error
      </p>
    </div>
    <div class="err" id="div2">another error</div>
  </body>
</html>
```
	
И следующие правила:

```css
div {margin:5px;color:black}
.err {color:red}
.big {margin-top:3px}
div span {margin-bottom:4px}
#div1 {color:blue}
#div2 {color:green}
```
	
Для упрощения скажем, нам нужно заполнить только две структуры: структуру цвета и структуру поля(margin). Цветовая структура содержит только один элемент: цвет. Структура поля содержит четыре стороны.
Результирующее дерево правил будет выглядеть так (узлы помечены именем узла: номер правила, на которое они указывают):

 ![](/images/39e33993b9ab53dd6e255c31eb408454.png) 

 Рисунок: Дерево правил

  
Контекстное дерево будет выглядеть следующим образом (имя узла: узел правила, на который они указывают):

 ![](/images/4a359526d4ec97918c333419ef8ce9ae.png) 

 Рисунок: контекстное дерево

Предположим, что мы анализируем HTML и переходим ко второму тегу \<div>. Нам нужно создать контекст стиля для этого узла и заполнить его стилевые структуры.
Мы сопоставим правила и обнаружим, что соответствующие правила для \<div>: 1, 2 и 6. Это означает, что в дереве уже существует существующий путь, который может использовать наш элемент, и нам просто нужно добавить в него другой узел для правила 6 (узел F в дереве правил).
Мы создадим контекст стиля и поместим его в контекстное дерево. Новый контекст стиля будет указывать на узел F в дереве правил.

Теперь нам нужно заполнить стилевые структуры. Мы начнем с заполнения структуры поля. Поскольку последний узел правила (F) не добавляет к структуре маржи, мы можем идти вверх по дереву, пока не найдем кэшированную структуру, вычисленную в предыдущей вставке узла, и использовать ее. Мы найдем его на узле B, который является самым верхним узлом, на котором указаны правила полей.

У нас есть определение для структуры цвета, поэтому мы не можем использовать кэшированную структуру. Так как цвет имеет один атрибут, нам не нужно подниматься вверх по дереву, чтобы заполнить другие атрибуты. Мы вычислим конечное значение (преобразуем строку в RGB и т. д.) и кэшируем вычисленную структуру на этом узле.

Работать со вторым элементом \<span> еще проще. Мы сопоставим правила и придем к выводу, что оно указывает на правило G, как и предыдущий промежуток. Поскольку у нас есть братья и сестры, которые указывают на один и тот же узел, мы можем использовать общий контекст стиля и просто указать на контекст предыдущего диапазона.

Для структур, которые содержат правила, унаследованные от родительского, кэширование выполняется в дереве контекста (свойство цвета на самом деле наследуется, но Firefox рассматривает его как сброс и кэширует его в дереве правил).
Например, если мы добавили правила для шрифтов в абзаце:

```css
p {font-family: Verdana; font size: 10px; font-weight: bold}
```
	
Тогда элемент абзаца, который является дочерним элементом для div в контекстном дереве, мог иметь ту же структуру шрифта, что и его родительский элемент. Это если для абзаца не было указано никаких правил шрифта.

В WebKit, у которого нет дерева правил, сопоставленные объявления просматриваются четыре раза. Сначала применяются не важные важные свойства с высоким приоритетом (свойства, которые должны применяться в первую очередь, потому что другие зависят от них, например, отображение), затем важные с высоким приоритетом, затем не имеющие важного значения с нормальным приоритетом, а затем важные правила с обычным приоритетом. Это означает, что свойства, которые появляются несколько раз, будут разрешаться в соответствии с правильным порядком каскада. Последние побеждают. 

Итак, подведем итог: совместное использование стилевых объектов (целиком или некоторых структур внутри них) решает проблемы [1](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#issue1) и [3]( https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#issue3). Дерево правил Firefox также помогает применять свойства в правильном порядке.

### Манипулирование правилами для простого поиска

Существует несколько источников правил стиля:

* Правила CSS, либо во внешних таблицах стилей, либо в элементах стиля.
    
```css
    p {color: blue}
```
	
* Встроенные атрибуты стиля, такие как

```html
    <p style="color: blue" />
```
	
* Визуальные атрибуты HTML (которые сопоставлены с соответствующими правилами стиля)

```html
    <p bgcolor="blue" />
```

Последние два легко сопоставляются с элементом, поскольку он владеет атрибутами стиля, а атрибуты HTML могут быть сопоставлены с использованием элемента в качестве ключа.

Как отмечалось ранее в [выпуске № 2](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#issue2), сопоставление правил CSS может быть сложнее. Чтобы решить сложность, правилами манипулируют для более легкого доступа.

После анализа таблицы стилей правила добавляются в одну из нескольких хэш-карт в соответствии с селектором. Есть карты по идентификатору, по имени класса, по имени тега и общая карта для всего, что не вписывается в эти категории. Если селектор является идентификатором, правило будет добавлено к карте идентификаторов, если это класс, оно будет добавлено к карте классов и т. Д.
Эта манипуляция значительно упрощает соответствие правилам. Нет необходимости просматривать каждую декларацию: мы можем извлечь соответствующие правила для элемента из карт. Эта оптимизация исключает более 95% правил, поэтому их даже не нужно учитывать в процессе сопоставления ([4.1](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#4_1)).

Давайте рассмотрим, например, следующие правила стиля:

```css
p.error {color: red}
#messageDiv {height: 50px}
div {margin: 5px}
```
	
Первое правило будет вставлено в карту классов. Второй в карту идентификаторов и третий в карту тегов.
Для следующего фрагмента HTML;

```html
<p class="error">an error occurred </p>
<div id=" messageDiv">this is a message</div>
```
	
Сначала мы попытаемся найти правила для элемента p. Карта классов будет содержать ключ «error», по которому найдено правило для «p.error». Элемент div будет иметь соответствующие правила в карте идентификаторов (ключ - идентификатор) и карте тегов. Таким образом, единственной оставшейся работой является выяснение, какие из правил, которые были извлечены ключами, действительно совпадают.
Например, если правило для div было

```css
table div {margin: 5px}
```
	
он все равно будет извлечен из карты тегов, потому что ключ является самым правым селектором, но он не будет соответствовать нашему элементу div, у которого нет предка таблицы.

И WebKit, и Firefox делают эту манипуляцию.

### Применение правил в правильном каскадном порядке

У объекта стиля есть свойства, соответствующие каждому визуальному атрибуту (все атрибуты CSS, но более общие). Если свойство не определено ни одним из соответствующих правил, некоторые свойства могут наследоваться объектом стиля родительского элемента. Другие свойства имеют значения по умолчанию.

Проблема начинается, когда существует более одного определения - здесь следует каскадный порядок решения проблемы.

### Каскадная таблица стилей заказа

Объявление для свойства стиля может появляться в нескольких таблицах стилей и несколько раз в таблице стилей. Это означает, что порядок применения правил очень важен. Это называется «каскадным» порядком. Согласно спецификации CSS2, порядок каскадирования (от низкого до высокого):

1. Объявления браузера
2. Пользовательские обычные объявления
3. Автор нормальных объявлений
4. Автор важных объявлений
5. Пользователь важные объявления

Объявления браузера являются наименее важными, и пользователь переопределяет автора, только если объявление было помечено как важное. Объявления с одинаковым порядком будут отсортированы по [специфичности](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Specificity), а затем по порядку, в котором они указаны. Визуальные атрибуты HTML переводятся в соответствующие объявления CSS. Они рассматриваются как авторские правила с низким приоритетом.

### специфичность

Специфичность селектора определяется [спецификацией CSS2](http://www.w3.org/TR/CSS2/cascade.html#specificity) следующим образом:

* считать 1, если декларация является атрибутом стиля, а не правилом с селектором, в противном случае 0 (= a)
* подсчитать количество атрибутов ID в селекторе (= b)
* подсчитать количество других атрибутов и псевдоклассов в селекторе (= c)
* подсчитать количество имен элементов и псевдоэлементов в селекторе (= d)

Конкатенация четырех чисел a-b-c-d (в системе счисления с большой базой) дает специфичность.

Числовая база, которую вам нужно использовать, определяется наибольшим количеством, которое у вас есть в одной из категорий.
Например, если a = 14, вы можете использовать шестнадцатеричное основание. В маловероятном случае, когда a = 17, вам понадобится 17-значный номер базы. Более поздняя ситуация может произойти с таким селектором, как этот: html body div div p ... (17 тэгов в вашем селекторе ... маловероятно).

Некоторые примеры:

```css
 *             {}  /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */
 li            {}  /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */
 li:first-line {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul li         {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul ol+li      {}  /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */
 h1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */
 ul ol li.red  {}  /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */
 li.red.level  {}  /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */
 #x34y         {}  /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */
 style=""          /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */
```
	
### Сортировка правил

После сопоставления правил они сортируются в соответствии с правилами каскада. WebKit использует пузырьковую сортировку для небольших списков и сортировку слиянием для больших. WebKit реализует сортировку путем переопределения оператора ">" для правил:

```c++
static bool operator >(CSSRuleData& r1, CSSRuleData& r2)
{
    int spec1 = r1.selector()->specificity();
    int spec2 = r2.selector()->specificity();
    return (spec1 == spec2) : r1.position() > r2.position() : spec1 > spec2;
}
```
	
### Постепенный процесс

WebKit использует флаг, который отмечает, были ли загружены все таблицы стилей верхнего уровня (включая @imports). Если при подключении стиль загружен не полностью, используются заполнители, и он отмечается в документе, и они будут пересчитаны после загрузки таблиц стилей.

## расположение, компоновка

Когда средство визуализации создано и добавлено в дерево, оно не имеет позиции и размера. Расчет этих значений называется макетом или перекомпоновкой.

HTML использует модель макета на основе потока, что означает, что большую часть времени можно вычислить геометрию за один проход. Элементы позже "в потоке" обычно не влияют на геометрию элементов, которые раньше "в потоке", поэтому макет может проходить слева направо, сверху вниз через документ , Существуют исключения: например, для таблиц HTML может потребоваться более одного прохода ([3.5](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#3_5)).

Система координат относительно корневой рамки. Верхняя и левая координаты используются.

Макет является рекурсивным процессом. Он начинается с корневого средства визуализации, которое соответствует элементу `<html>` документа HTML. Макет продолжается рекурсивно по некоторой или всей иерархии фреймов, вычисляя геометрическую информацию для каждого средства визуализации, которое в этом нуждается.

Положение корневого средства визуализации равно 0,0, а его размеры - область просмотра - видимая часть окна браузера.

Все средства визуализации имеют метод «layout» или «reflow», каждый модуль визуализации вызывает метод layout для своих дочерних элементов, которым требуется layout.

### Грязная битовая система

Чтобы не делать полный макет для каждого небольшого изменения, браузеры используют систему "грязного бита". Рендерер, который был изменен или добавлен, помечает себя и своих потомков как «грязный»: требуется макет

Есть два флага: «грязный» и «дочерний элемент грязный», что означает, что, хотя само средство визуализации может быть в порядке, у него есть по крайней мере один дочерний элемент, которому требуется макет.

### Глобальный и инкрементный макет

Макет может быть запущен на всем дереве рендеринга - это «глобальный» макет. Это может произойти в результате:

1. Глобальное изменение стиля, которое влияет на все средства визуализации, например, изменение размера шрифта.
2. В результате изменения размера экрана

Макет может быть инкрементным, будут размещены только грязные рендеры (это может привести к некоторому повреждению, которое потребует дополнительных макетов).
Инкрементная компоновка запускается (асинхронно), когда рендеры грязные. Например, когда новые средства визуализации добавляются в дерево визуализации после того, как дополнительный контент поступил из сети и был добавлен в дерево DOM.

 ![](/images/e1a4409f5f5ddf1f13b63ad25c13f0d2.png) 

Рисунок: добавочный макет - выкладываются только грязные рендеры и их дочерние элементы ([3.6](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#3_6))

### Асинхронный и синхронный макет

Инкрементная верстка выполняется асинхронно. Firefox ставит в очередь «команды перекомпоновки» для инкрементных макетов, и планировщик запускает пакетное выполнение этих команд. В WebKit также есть таймер, который выполняет инкрементную компоновку - дерево обходится, а «грязные» средства визуализации размечаются.
Скрипты, запрашивающие информацию о стиле, например, «offsetHeight», могут синхронно запускать инкрементный макет.
Глобальный макет обычно запускается синхронно.
Иногда макет вызывается как обратный вызов после первоначального макета, потому что некоторые атрибуты, такие как позиция прокрутки, изменились.

### Оптимизации

Когда макет вызывается «изменением размера» или изменением позиции рендеринга (а не размера), размеры рендера берутся из кэша и не пересчитываются.
В некоторых случаях изменяется только поддерево, и макет не начинается с корня. Это может произойти в тех случаях, когда изменение является локальным и не влияет на его окружение - например, текст, вставленный в текстовые поля (в противном случае каждое нажатие клавиши будет вызывать макет, начиная с корня).

### Процесс верстки

Макет обычно имеет следующий шаблон:

1. Родительский рендер определяет свою ширину.
2. Родитель идет за детьми и:
    1. Поместите дочерний рендер (задает его x и y).
    2. При необходимости вызывает дочерний макет - он грязный, или мы находимся в глобальном макете, или по какой-то другой причине - который вычисляет рост ребенка.
3. Родитель использует накопленную высоту детей, а также высоту полей и отступов, чтобы установить свою собственную высоту - это будет использоваться родителем родительского средства визуализации.
4. Устанавливает грязный бит в ложь.

Firefox использует объект «состояние» (nsHTMLReflowState) в качестве параметра для макета (называется «перекомпоновка»). Среди прочего в штат входит ширина родителей.
Результатом макета Firefox является объект «метрики» (nsHTMLReflowMetrics). Он будет содержать вычисленную высоту рендерера.

### Расчет ширины

Ширина рендерера рассчитывается с использованием ширины блока контейнера, свойства стиля рендера "width", полей и границ.
Например ширина следующего div:

```html
<div style="width: 30%"/>
```
	
Будет рассчитываться WebKit следующим образом (метод RenderBox класса calcWidth):

* Ширина контейнера - это максимум доступных контейнеров и 0. Доступная ширина в этом случае - это ширина содержимого, которая вычисляется как:
    
    clientWidth () - paddingLeft () - paddingRight ()
    
    clientWidth и clientHeight представляют внутреннюю часть объекта, исключая рамку и полосу прокрутки.
* Ширина элементов - это атрибут стиля "ширина". Он будет рассчитан как абсолютное значение путем вычисления процента от ширины контейнера.
* Добавлены горизонтальные границы и отступы.

So far this was the calculation of the "preferred width". Now the minimum and maximum widths will be calculated.  
If the preferred width is greater then the maximum width, the maximum width is used. If it is less then the minimum width (the smallest unbreakable unit) then the minimum width is used.

The values are cached in case a layout is needed, but the width does not change.

### Line Breaking

When a renderer in the middle of a layout decides that it needs to break, the renderer stops and propagates to the layout's parent that it needs to be broken. The parent creates the extra renderers and calls layout on them.

## Painting

In the painting stage, the render tree is traversed and the renderer's "paint()" method is called to display content on the screen. Painting uses the UI infrastructure component.

### Global and Incremental

Like layout, painting can also be global–the entire tree is painted–or incremental. In incremental painting, some of the renderers change in a way that does not affect the entire tree. The changed renderer invalidates its rectangle on the screen. This causes the OS to see it as a "dirty region" and generate a "paint" event. The OS does it cleverly and coalesces several regions into one. In Chrome it is more complicated because the renderer is in a different process then the main process. Chrome simulates the OS behavior to some extent. The presentation listens to these events and delegates the message to the render root. The tree is traversed until the relevant renderer is reached. It will repaint itself (and usually its children).

### The painting order

 [CSS2 defines the order of the painting process](http://www.w3.org/TR/CSS21/zindex.html) . This is actually the order in which the elements are stacked in the [stacking contexts](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#stackingcontext) . This order affects painting since the stacks are painted from back to front. The stacking order of a block renderer is:

1.  background color
2.  background image
3.  border
4.  children
5.  outline

### Firefox display list

Firefox goes over the render tree and builds a display list for the painted rectangular. It contains the renderers relevant for the rectangular, in the right painting order (backgrounds of the renderers, then borders etc). That way the tree needs to be traversed only once for a repaint instead of several times–painting all backgrounds, then all images, then all borders etc.

Firefox optimizes the process by not adding elements that will be hidden, like elements completely beneath other opaque elements.

#### WebKit rectangle storage

Before repainting, WebKit saves the old rectangle as a bitmap. It then paints only the delta between the new and old rectangles.  

### Dynamic changes

The browsers try to do the minimal possible actions in response to a change. So changes to an element's color will cause only repaint of the element. Changes to the element position will cause layout and repaint of the element, its children and possibly siblings. Adding a DOM node will cause layout and repaint of the node. Major changes, like increasing font size of the "html" element, will cause invalidation of caches, relayout and repaint of the entire tree.

### The rendering engine's threads

The rendering engine is single threaded. Almost everything, except network operations, happens in a single thread. In Firefox and Safari this is the main thread of the browser. In Chrome it's the tab process main thread.  
Network operations can be performed by several parallel threads. The number of parallel connections is limited (usually 2–6 connections).

### Event loop

The browser main thread is an event loop. It's an infinite loop that keeps the process alive. It waits for events (like layout and paint events) and processes them. This is Firefox code for the main event loop:

```c++
while (!mExiting)
    NS_ProcessNextEvent(thread);
```
	
## CSS2 visual model

### The canvas

According to the [CSS2 specification](http://www.w3.org/TR/CSS21/intro.html#processing-model) , the term canvas describes "the space where the formatting structure is rendered": where the browser paints the content. The canvas is infinite for each dimension of the space but browsers choose an initial width based on the dimensions of the viewport.

According to [www.w3.org/TR/CSS2/zindex.html](http://www.w3.org/TR/CSS2/zindex.html) , the canvas is transparent if contained within another, and given a browser defined color if it is not.

### CSS Box model

The [CSS box model](http://www.w3.org/TR/CSS2/box.html) describes the rectangular boxes that are generated for elements in the document tree and laid out according to the visual formatting model.  
Each box has a content area (e.g. text, an image, etc.) and optional surrounding padding, border, and margin areas.

 ![](/images/3df590c8c226fb5b5bbc5bf23a35ba91.jpg) 

 Figure : CSS2 box model

Each node generates 0..n such boxes.  
All elements have a "display" property that determines the type of box that will be generated. Examples:

block: generates a block box.
inline: generates one or more inline boxes.
none: no box is generated.

The default is inline but the browser style sheet may set other defaults. For example: the default display for the "div" element is block.  
You can find a default style sheet example here: [www.w3.org/TR/CSS2/sample.html](http://www.w3.org/TR/CSS2/sample.html) 

### Positioning scheme

There are three schemes:

1.  Normal: the object is positioned according to its place in the document. This means its place in the render tree is like its place in the DOM tree and laid out according to its box type and dimensions
2.  Float: the object is first laid out like normal flow, then moved as far left or right as possible
3.  Absolute: the object is put in the render tree in a different place than in the DOM tree

The positioning scheme is set by the "position" property and the "float" attribute.

*   static and relative cause a normal flow
*   absolute and fixed cause absolute positioning

  
In static positioning no position is defined and the default positioning is used. In the other schemes, the author specifies the position: top, bottom, left, right.

The way the box is laid out is determined by:

*   Box type
*   Box dimensions
*   Positioning scheme
*   External information such as image size and the size of the screen

### Box types

Block box: forms a block–has its own rectangle in the browser window.

 ![](/images/b4ebeebc1b883d92bef6ecf9746ae991.png) 

 Figure : Block box

Inline box: does not have its own block, but is inside a containing block.

 ![](/images/4ebcc8f249772dbf51f675ecefe79df8.png) 

 Figure : Inline boxes

Blocks are formatted vertically one after the other. Inlines are formatted horizontally.

 ![](/images/2732ebdc66ab6b23c0aadf20af53aac8.png) 

 Figure : Block and Inline formatting

Inline boxes are put inside lines or "line boxes". The lines are at least as tall as the tallest box but can be taller, when the boxes are aligned "baseline"–meaning the bottom part of an element is aligned at a point of another box other then the bottom. If the container width is not enough, the inlines will be put on several lines. This is usually what happens in a paragraph.

 ![](/images/87c30dad79f7107fc881c62609894ae5.png) 

 Figure : Lines

### Positioning

#### Relative

Relative positioning–positioned like usual and then moved by the required delta.

 ![](/images/486e61626640f3c537cb4807170e3317.png) 

 Figure : Relative positioning

#### Floats

A float box is shifted to the left or right of a line. The interesting feature is that the other boxes flow around it. The HTML:

```html
<p>
  <img style="float: right" src="images/image.gif" width="100" height="100">
  Lorem ipsum dolor sit amet, consectetuer...
</p>
```
	
Will look like:

 ![](/images/44f398158e9e4500a2fe33741e222ad5.png) 

 Figure : Float

#### Absolute and fixed

The layout is defined exactly regardless of the normal flow. The element does not participate in the normal flow. The dimensions are relative to the container. In fixed, the container is the viewport.

 ![](/images/b05dd35df5ed63b606f42fb18748b26d.png) 

 Figure : Fixed positioning

  
Note: the fixed box will not move even when the document is scrolled!

### Layered representation

This is specified by the z-index CSS property. It represents the third dimension of the box: its position along the "z axis".

The boxes are divided intostacks(called stacking contexts). In each stack the back elements will be painted first and the forward elements on top, closer to the user. In case of overlap the foremost element will hide the former element.  
The stacks are ordered according to the z-index property. Boxes with "z-index" property form a local stack. The viewport has the outer stack.

Example:

```html
<style type="text/css">
      div {
        position: absolute;
        left: 2in;
        top: 2in;
      }
</style>

<p>
    <div
         style="z-index: 3;background-color:red; width: 1in; height: 1in; ">
    </div>
    <div
         style="z-index: 1;background-color:green;width: 2in; height: 2in;">
    </div>
 </p>
```
	
The result will be this:

 ![](/images/22af0cbe246d399bab969d9ef699d1ea.png) 

 Figure : Fixed positioning

Although the red div precedes the green one in the markup, and would have been painted before in the regular flow, the z-index property is higher, so it is more forward in the stack held by the root box.

## Resources

1.  Browser architecture
    1.  Grosskurth, Alan. [A Reference Architecture for Web Browsers (pdf)](http://grosskurth.ca/papers/browser-refarch.pdf) 
    2.  Gupta, Vineet. [How Browsers Work–Part 1–Architecture](http://www.vineetgupta.com/2010/11/how-browsers-work-part-1-architecture/) 
2.  Parsing
    1.  Aho, Sethi, Ullman, Compilers: Principles, Techniques, and Tools (aka the "Dragon book"), Addison-Wesley, 1986
    2.  Rick Jelliffe. [The Bold and the Beautiful: two new drafts for HTML 5.](http://broadcast.oreilly.com/2009/05/the-bold-and-the-beautiful-two.html) 
3.  Firefox
    1.  L. David Baron, [Faster HTML and CSS: Layout Engine Internals for Web Developers.](http://dbaron.org/talks/2008-11-12-faster-html-and-css/slide-6.xhtml) 
    2.  L. David Baron, [Faster HTML and CSS: Layout Engine Internals for Web Developers (Google tech talk video)](https://www.youtube.com/watch?v=a2_6bGNZ7bA) 
    3.  L. David Baron, [Mozilla's Layout Engine](http://www.mozilla.org/newlayout/doc/layout-2006-07-12/slide-6.xhtml) 
    4.  L. David Baron, [Mozilla Style System Documentation](http://www.mozilla.org/newlayout/doc/style-system.html) 
    5.  Chris Waterson, [Notes on HTML Reflow](http://www.mozilla.org/newlayout/doc/reflow.html) 
    6.  Chris Waterson, [Gecko Overview](http://www.mozilla.org/newlayout/doc/gecko-overview.htm) 
    7.  Alexander Larsson, [The life of an HTML HTTP request](https://developer.mozilla.org/en/The_life_of_an_HTML_HTTP_request) 
4.  WebKit
    1.  David Hyatt, [Implementing CSS(part 1)](http://weblogs.mozillazine.org/hyatt/archives/cat_safari.html) 
    2.  David Hyatt, [An Overview of WebCore](http://weblogs.mozillazine.org/hyatt/WebCore/chapter2.html) 
    3.  David Hyatt, [WebCore Rendering](http://webkit.org/blog/114/) 
    4.  David Hyatt, [The FOUC Problem](http://webkit.org/blog/66/the-fouc-problem/) 
5.  W3C Specifications
    1.   [HTML 4.01 Specification](http://www.w3.org/TR/html4/) 
    2.   [W3C HTML5 Specification](http://dev.w3.org/html5/spec/Overview.html) 
    3.   [Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification](http://www.w3.org/TR/CSS2/) 
6.  Browsers build instructions
    1.  Firefox. [https://developer.mozilla.org/en/Build\_Documentation](https://developer.mozilla.org/en/Build_Documentation) 
    2.  WebKit. [http://webkit.org/building/build.html](http://webkit.org/building/build.html)




**********
[CSS](/tags/CSS.md)
[НЕ ПЕРЕВЕДЕНО](/tags/%D0%9D%D0%95%20%D0%9F%D0%95%D0%A0%D0%95%D0%92%D0%95%D0%94%D0%95%D0%9D%D0%9E.md)
[Как работает](/tags/%D0%9A%D0%B0%D0%BA%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82.md)
[HTML](/tags/HTML.md)
[DOM](/tags/DOM.md)
